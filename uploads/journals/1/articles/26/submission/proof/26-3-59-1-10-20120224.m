(* ::Package:: *)

(* ::Input:: *)
(*DivisioEntera[a_,b_]:=Module[{q},*)
(*q=IntegerPart[Divide[a,b]];*)
(*r=a-b*q;*)
(*Return[{q,r}];*)
(*]*)


(* ::Input:: *)
(*GF[p_,n_]:=Module[{help,Fi,i,GF},*)
(*help=1;*)
(*Fi=False;*)
(*i=1;*)
(*GF={{-Infinity,0},{0,1}};*)
(*While[!Fi,*)
(*help=PolynomialMod[PolynomialRemainder[help*x,p,x],n];*)
(*If[help==1,*)
(*Fi = True*)
(*];*)
(*GF=Append[GF,{\[Alpha]^i,help}];*)
(*i++;*)
(*];*)
(*Return[MatrixForm[GF]];*)
(*]*)


(* ::Input:: *)
(*LogaritmeZech[M_]:=Module[{LogZech,paux,i,j},*)
(*LogZech={};*)
(*For[i=3,i<Length[M[[1]]],i++,*)
(*paux=PolynomialMod[1+M[[1,i,2]],2];*)
(*(*Print[paux];*)*)
(*For[j=1,j<=Length[M[[1]]],j++,*)
(*If[paux===M[[1,j,2]],*)
(*LogZech=Append[LogZech,j-2];*)
(*(*Print[(j-2)," -> ",paux ,"->",(i-2)]*)*)
(*]*)
(*]*)
(*];*)
(*Return[LogZech];*)
(*]*)


(* ::Input:: *)
(*OrdrePol[pol_,n_]:=Module[{M,trobat,i,aux,a,ordre},*)
(*M=GF[pol,2];*)
(*a=M[[1,n+2,2]];*)
(*trobat=False;*)
(*For[i=1,(i<=Length[M[[1]]])&&(!trobat),i++,*)
(*aux=PolynomialMod[PolynomialMod[a^i,pol],2];*)
(*If[Exponent[aux,x]==0,trobat=True]*)
(*];*)
(*If[trobat,*)
(*ordre=i-1;*)
(*(*Return[ordre]*)*)
(*For[i=2,i<=Length[M[[1]]],i++,*)
(*If[DivisioEntera[2^i-1,ordre][[2]]==0,Return[i]]*)
(*],*)
(*Print["ERROR"];*)
(**)
(*]*)
(*]*)


(* ::Input:: *)
(*PolinomiMinim[p_,exp_]:=Module[{aux=1,M,i,j,NewPol,pot,help,help2,*)
(*var,cardinalGF,GrauPol,Resultat,parcial,coeficient,mgrau,coef2,petitenter},*)
(*M=GF[p,2];*)
(*petitenter=OrdrePol[p,exp];*)
(*cardinalGF=Length[M[[1]]]-1;*)
(*For[i=0,i<=petitenter-1,i++,*)
(*pot=exp*(2^i);*)
(*aux=aux*(x-\[Alpha]^pot);*)
(*];*)
(*aux=Expand[PolynomialMod[aux,2]];*)
(*Return[SimplificarExpressio[M,aux]];*)
(*]*)


(* ::Input:: *)
(*SimplificarExpressio[M_,aux_]:=Module[{NewPol,help,j,i,k,help2,var,*)
(*GrauPol,coeficient,coef2,parcial,Resultat,mgrau,cardinalGF,auxi},*)
(*auxi=PolynomialMod[aux,2];*)
(*cardinalGF=Length[M[[1]]]-1;*)
(*NewPol=0;*)
(*For[i=0,i<=Exponent[auxi,x],i++,*)
(*help=Coefficient[auxi,x,i];*)
(**)
(*For[j=cardinalGF-1,j<=Exponent[help,\[Alpha]],j++,*)
(*help2=Coefficient[help,\[Alpha],j];*)
(*If[help2!=0,*)
(*var=PolynomialMod[j,cardinalGF-1];*)
(*help=help-help2*\[Alpha]^j+\[Alpha]^var;*)
(*]*)
(*];*)
(*NewPol=NewPol+help*x^i;*)
(*];*)
(*NewPol=PolynomialMod[NewPol,2];*)
(**)
(*GrauPol=Exponent[NewPol,x];*)
(*Resultat=0;*)
(**)
(*For[i=0,i<=GrauPol,i++,*)
(*coeficient=Coefficient[NewPol,x,i];*)
(**)
(*mgrau=Exponent[coeficient,\[Alpha]];*)
(**)
(*If[mgrau>0, *)
(*parcial=0;*)
(*For[j=0,j<=mgrau,j++,*)
(*	coef2=Coefficient[coeficient,\[Alpha],j];*)
(*	If[coef2!=0,*)
(*		parcial=PolynomialMod[parcial+M[[1,j+2,2]],2]*)
(*	];*)
(*];*)
(**)
(*For[k=3,k<Length[M[[1]]],k++,*)
(*If[M[[1,k,2]]===parcial,*)
(*parcial= M[[1,k,1]];*)
(*]*)
(*],*)
(*If[mgrau==0, parcial=1, parcial=0];*)
(*];*)
(*parcial=PolynomialMod[parcial,2];*)
(**)
(*Resultat=PolynomialMod[Resultat+parcial*x^i,2];*)
(**)
(*];*)
(*Return[Resultat];*)
(*]*)
(**)


(* ::Input:: *)
(*BCH[pol_,t_]:=Module[{M,g,i,n,expg,dim,m,alphas(*,ordres*)},*)
(*alphas={};*)
(*(*ordres={};*)*)
(*For[i=1,i<=t,i++, *)
(*alphas=Append[alphas,2*i-1];*)
(*(*ordres=Append[ordres,OrdrePol[pol,2*i-1]];*)*)
(*];*)
(*M=GF[pol,2];*)
(*m=Exponent[pol,x];*)
(*g=1;*)
(*For[i=1,i<=Length[alphas],i++,*)
(*g=g*PolinomiMinim[pol,alphas[[i]](*,ordres[[i]]*)];*)
(*];*)
(*g=PolynomialMod[g,2];*)
(*n=2^m-1;*)
(*expg=Exponent[g,x];*)
(*dim=n-expg;*)
(*Print["El codi BCH construit t\[EAcute] longitud ",n,", dimensi\[OAcute] ",dim,", capacitat correctora ",t,",*)
(* dist\[AGrave]ncia m\[IAcute]nima entre les paraules ",2*t+1,", i el seu polinomi generador \[EAcute]s g(x)= ",g];*)
(*Return[g];*)
(*]*)


(* ::Input:: *)
(*Codificacio[missatgevect_,g_]:=Module[{long,basemissatge,i},*)
(*long=Length[missatgevect];*)
(*basemissatge={1};*)
(*For[i=1,i<long,i++,*)
(*basemissatge=Append[basemissatge,x^i];*)
(*];*)
(*a=missatgevect.basemissatge;*)
(*v=Expand[PolynomialMod[a*g,2]];*)
(**)
(*Return[v]*)
(*]*)


(* ::Input:: *)
(*RS[p_,d_]:=Module[{aux,i,k,n,M,m},*)
(*M=GF[p,2];*)
(*m=Exponent[p,x];*)
(*n=2^m-1;(*longitud del codi*)*)
(*k=n-(d-1);(*dimensio del codi*)*)
(*aux=1;*)
(*For[i=1,i<=d-1,i++,*)
(*aux=aux*(x-\[Alpha]^i);*)
(*];*)
(*aux=Expand[aux];*)
(*aux=SimplificarExpressio[M,aux];*)
(*Print["El codi RS construit t\[EAcute] longitud ",n,", dimensi\[OAcute] ",k,", capacitat correctora ",IntegerPart[(d-1)/2],", dist\[AGrave]ncia m\[IAcute]nima entre les paraules ",d,", i el seu polinomi generador \[EAcute]s g(x)= ",aux];*)
(*Return[aux];*)
(*]*)


(* ::Input:: *)
(*SistematicCode[paraula_,g_,d_]:=Module[{base,i,a,p,v},*)
(*base={1};*)
(*(*M=GF[p,2];*)*)
(*For[i=1,i<d,i++,base=Append[base,x^i];];*)
(*a=paraula.base;*)
(*p=PolynomialMod[a*x^(d-1),g];*)
(*v=a*x^(d-1)-p;*)
(*v=Expand[PolynomialMod[v,2]];*)
(*SimplificarExpressio[M,v]*)
(**)
(*]*)


(* ::Input:: *)
(*SimplificarQuocient[Paux_,M_]:=Module[{aux,i,pluus},*)
(*aux=0;*)
(**)
(*For[i=0,i<=Exponent[Paux,x],i++,*)
(*If[i==0,*)
(*x=0;*)
(*If[Exponent[Paux,\[Alpha]]!=0&&Exponent[Paux,\[Alpha]]!=-Infinity,*)
(*pluus=Expand[Numerator[Together[Paux]]*\[Alpha]^PolynomialMod[Exponent[1/Denominator[Together[Paux]],\[Alpha]],Length[M[[1]]]-2]];*)
(*pluus=PolynomialMod[pluus,2];*)
(*aux=aux+pluus,*)
(*If[Exponent[Paux,\[Alpha]]==0,*)
(*aux=aux+1*)
(*]*)
(*];*)
(*Clear[x],*)
(*aux=SimplificarExpressio[M,aux];*)
(*If[Exponent[Coefficient[Paux,x^i],\[Alpha]]!=0 && Exponent[Coefficient[Paux,x^i],\[Alpha]]!=-Infinity,*)
(*aux=aux+x^i*\[Alpha]^PolynomialMod[Exponent[Coefficient[Paux,x^i],\[Alpha]],Length[M[[1]]]-2],*)
(*aux=aux+Coefficient[Paux,x^i]*x^i;*)
(*]*)
(**)
(*]*)
(*];*)
(*Return[aux]*)
(*]*)


(* ::Input:: *)
(*DivisionsSuccessives[S_,d_]:=Module[{Taula,t,i,aux,quot,mat},*)
(*t=IntegerPart[(d-1)/2];*)
(*Taula={{S,x^(d-1),PolynomialMod[S,x^(d-1)],PolynomialQuotient[S,x^(d-1),x]}};*)
(*(*Taula={{S,g,PolynomialMod[S,g],PolynomialQuotient[S,g,x]}};*)*)
(*i=1;*)
(*While[Exponent[Taula[[i,3]],x]>=t,*)
(*quot=SimplificarQuocient[PolynomialQuotient[Taula[[i,2]],Taula[[i,3]],x],M];*)
(*quot=PolynomialMod[quot,2];*)
(*aux={Taula[[i,2]],*)
(*Taula[[i,3]],*)
(*SimplificarExpressio[M,Expand[Taula[[i,2]]-Taula[[i,3]]*quot]],*)
(*quot};*)
(*Taula=Append[Taula,aux];*)
(*i++;*)
(*];*)
(**)
(*mat={{Taula[[1,4]],1},{1,0}};*)
(*For[i=2,i<=Length[Taula[[1]]],i++,*)
(*mat={{Taula[[i,4]],1},{1,0}}.mat;*)
(*];*)
(*Return[{MatrixForm[Taula],MatrixForm[Expand[mat]]}];*)
(**)
(*]*)
(**)


(* ::Input:: *)
(*Sindrome[u_,M_,d_]:=Module[{help,aux,i,S},*)
(*S=0;*)
(*For[i=1,i<=d-1,i++,*)
(*x=\[Alpha]^i;*)
(*help=PolynomialMod[u,2];*)
(*Clear[x];*)
(*aux=SimplificarExpressio[M,help];*)
(*S=S+aux*x^(i-1);*)
(*];*)
(*Return[S];*)
(*]*)


(* ::Input:: *)
(*Descodificacio[u_,g_,M_,d_,longCodi_,sistem_]:=Module[{S,aux,divisions,taula,\[Sigma],D\[Sigma],w,TT,pos,coordErr,i,exp,j,expon,num,den, errors,err,basepol,final,trobat},*)
(*S=Sindrome[u,M,d];*)
(*Print["S(x)= ",S];*)
(*aux=DivisionsSuccessives[S,d];*)
(**)
(*divisions=aux[[1]];*)
(*taula=aux[[2]];*)
(*Print["Taula: "divisions,", Matriu: ",taula];*)
(**)
(*\[Sigma]=SimplificarExpressio[M,PolynomialMod[taula[[1,1,2]],2]];*)
(*D\[Sigma]=PolynomialMod[D[\[Sigma],x],2];*)
(*w=((-1)^(Length[divisions[[1]]]-1))*(divisions[[1,Length[divisions[[1]]],3]]);*)
(*w=PolynomialMod[w,2];*)
(*Print["\[Sigma]: ",\[Sigma], ", D\[Sigma]: ", D\[Sigma],", w: ",w];*)
(**)
(*TT={};*)
(*pos={};*)
(*coordErr={};*)
(*For[i=0,i<Length[M[[1]]]-2,i++,*)
(*x=\[Alpha]^i;*)
(*exp=PolynomialMod[\[Sigma],2];*)
(*Clear[x];*)
(*If[Exponent[exp,\[Alpha]]!=0,*)
(*exp=SimplificarExpressio[M,exp]*)
(*];*)
(*If[exp==0,pos=Append[pos,i]];*)
(*TT=Append[TT,exp];*)
(*];*)
(*(*Print[TT];*)*)
(*coordErr=PolynomialMod[-pos+Length[M[[1]]]-2,Length[M[[1]]]-2];*)
(**)
(*errors={};*)
(*For[i=1,i<=Length[pos],i++,*)
(*x=\[Alpha]^pos[[i]];*)
(*aa=w/D\[Sigma];*)
(*Clear[x];*)
(*num=SimplificarExpressio[M,Numerator[aa]];*)
(*den=SimplificarExpressio[M,Denominator[aa]];*)
(*den=\[Alpha]^(-Exponent[den,\[Alpha]]+Length[M[[1]]]-2);*)
(*den=SimplificarExpressio[M,den];*)
(*aa=SimplificarExpressio[M,den*num];*)
(*errors=Append[errors,aa]*)
(*];*)
(*(*Print["errors                ",errors];*)
(*Print["posicions dels errors ",pos];*)*)
(**)
(*err={};*)
(*basepol={};*)
(*For[i=0,i<= longCodi,i++,*)
(*trobat=False;*)
(*For[j=1,j<=Length[errors],j++,*)
(*If[coordErr[[j]]==i,*)
(*trobat=True;*)
(*err=Append[err,errors[[j]]]*)
(*]*)
(*];*)
(*If[!trobat,err=Append[err,0];];*)
(*basepol=Append[basepol,x^i];*)
(*];*)
(*Print["El vector d'error introdu\[IDoubleDot]t ha estat: ", err.basepol];*)
(*final=SimplificarExpressio[M,PolynomialMod[u-err.basepol,2]];*)
(*If[!sistem,*)
(*final=SimplificarExpressio[M,PolynomialMod[PolynomialQuotient[final,g,x],2]];*)
(*];*)
(**)
(*Print["El missatge enviat ha estat: ", final];*)
(*Return[final];*)
(*]*)


(* ::Input:: *)
(*Ajuda[str_]:=Module[{},*)
(*	Print["Benvingut a l'ajudant per a la codificaci\[OAcute] emprant codis BCH i RS"];*)
(*	If[str=="GF",*)
(*	Print["Ha seleccionat ajuda sobre com construir un cos de Galois"];*)
(*	Print["Donat un polinomi p, si vol obtenir la taula en forma de matriu, corresponent al cos de Galois, sols ha d'introduir la instruccio:"];*)
(*	Print["              GF[p,2];"];*)
(*	Print["Se li recomana fer l'assignacio M=GF[p,2], doncs al llarg de la codificaci\[OAcute] necessitar\[AGrave] introduir de nou aquesta matriu per a futurs c\[AGrave]lculs"]*)
(*,*)
(*	If[str=="Zech",*)
(*	Print["Ha seleccionat ajuda sobre com obtenir una taula de Logarime de Zech sobre un cos de Galois"];*)
(*	Print["Donada una taula, M, corresponent a un cos de Galois sobre un polinomi p, i.e. M=GF[p,2]; si vol obtenir la taula en forma de matriu, corresponent al Logaritme de Zech, sobre dit cos, sols ha d'introduir la instrucci\[OAcute]:"];*)
(*	Print["              LogaritmeZech[M];"]*)
(*,*)
(*	If[str=="PolMin",*)
(*	Print["Ha seleccionat ajuda sobre polinomis m\[IAcute]nims sobre un cos de Galors"];*)
(*	Print["Si es desitja el polinomi m\[IAcute]nim, de \[Alpha]^n, dins un cos de Galois generat per p, sols ha d'introduir la instrucci\[OAcute]:"];*)
(*	Print["              PolinomiMinim[p,n];"]*)
(*,*)
(*	If[str=="BCH",*)
(*	Print["Ha seleccionat ajuda sobre codis BCH i la seva codificaci\[OAcute]"];*)
(*	Print["Si vol construir un codi BCH sobre un cos de Galois, creat a partir d'un polinomi p donat i amb capacitat correctora t, sols ha d'introduir la instrucci\[OAcute]: "];*)
(*	Print["              BCH[p,t];"];*)
(*	Print["Aquesta instrucci\[OAcute] tornar\[AGrave] tota la informaci\[OAcute] relativa al codi creat, com longitud, dimensi\[OAcute], capacitat correctora, dist\[AGrave]ncia m\[IAcute]nima i polinomi generador"];	Print["Si donat un BCH, amb polinomi generador g, vol codificar un polinomi de la forma a0+a1x+a2x^2+...+anx^n, on cada ai es zero o un, sols ha d'introduir la instrucci\[OAcute]: "];*)
(*	Print["              Codificacio[{a0,a1,a2,...,an},g];"]*)
(*,*)
(*	If[str=="RS",*)
(*	Print["Ha seleccionat ajuda sobre codis RS i la seva codificaci\[OAcute]"];*)
(*	Print["Si vol construir un codi RS sobre un cos de Galois, creat a partir d'un polinomi p donat i amb dist\[AGrave]ncia m\[IAcute]nima entre paraules d, sols ha d'introduir la instrucci\[OAcute]: "];*)
(*	Print["              RS[p,d];"];*)
(*	Print["Aquesta instrucci\[OAcute] tornar\[AGrave] tota la informaci\[OAcute] relativa al codi creat, com longitud, dimensi\[OAcute], capacitat correctora, dist\[AGrave]ncia m\[IAcute]nima i polinomi generador"];*)
(*	Print["Si donat un RS, amb polinomi generador g, amb d la dist\[AGrave]ncia m\[IAcute]nima entre les paraules obtinguda fent el RS pertinent, vol codificar de forma sistem\[AGrave]tica un polinomi de la forma a0+a1x+a2x^2+...+anx^n, on cada ai es zero, un o un cert \[Alpha]^i, sols ha d'introduir la instrucci\[OAcute]: "];*)
(*	Print["              SistematicCode[{a0,a1,a2,...,an},g,d];"];*)
(*,*)
(*If[str=="Descodificacio",*)
(*Print["Ha seleccionat ajuda sobre descodificacio de codis"];*)
(*Print["Sigui quin sigui el m\[EGrave]tode amb que hagi codificat, tamb\[EAcute] es podr\[AGrave] descodificar un cert missatge rebut u, que s'hagi codificat amb un polinomi generador g, sobre un cos de Galois amb matriu M, i amb un codi de dist\[AGrave]ncia m\[IAcute]nima d i longitud d. A m\[EAcute]s un darrer par\[AGrave]metre boole\[AGrave] True o False s'ha d'indicar sogons si s'ha fet una codificaci\[OAcute] sistem\[AGrave]tica o no. "];*)
(*Print["Codificacio Sistematica:              Descodificacio[u,g,M,d,l,True];"];*)
(*Print["Codificacio No Sistematica:              Descodificacio[u,g,M,d,l,False];"];*)
(*,*)
(*Print["Si vol consultar com construir un cos de Galois, introdueixi Ajuda[\"GF\"] "];*)
(*Print["Si vol consultar com construir una taula de Logaritme de Zech sobre un cos de Galois, introdueixi Ajuda[\"Zech\"] "];*)
(*Print["Si vol consultar la informaci\[OAcute] sobre polinomis m\[IAcute]nims sobre un cos de Galors, introdueixi Ajuda[\"PolMin\"] "];*)
(*Print["Si vol consultar la informaci\[OAcute] sobre codis BCH i la seva codificaci\[OAcute], introdueixi Ajuda[\"BCH\"] "];*)
(*Print["Si vol consultar la informaci\[OAcute] sobre codis RS i la seva codificaci\[OAcute], introdueixi Ajuda[\"RS\"] "];*)
(*Print["Si vol consultar la informaci\[OAcute] sobre descodificacions, introdueixi Ajuda[\"Descodificacio\"] "];*)
(*]*)
(*]*)
(*]*)
(*]*)
(*]*)
(*]*)
(*]*)
(**)
